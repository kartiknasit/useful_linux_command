Linux Commands to be remember

Commands to be run once you installed Ubuntu

add prefix sudo if need to run command as root

- sudo apt upgdade
- sudo apt full-upgrade

when we start linux automatically shell process is starts
shell is program which accepts user input and execute it
it is a command interpreter
shell gives command to linux kernel


man pages --> looked to check detail or documentation of command

man -> manual

For ex, man ls --> will display documentation of manual of command ls

we can search any string using /search_string
then to navigate each of the matches use n for next match and N (shift + n) for previous match

to go to beginning of the man page use g and to go to end press G (shift + g)

to search backward use ?serach_string

man page is only available for commands that have dedicated documentation or manuals in linux 
but man page is not available for commands that are shell built in
to check if command is built in or not
use, type command_name
to check help on this command use help command_name
help is only available for commands that are shell built in

we can also search for the exact or similar command using man
use, man -k search_string --> this will display exact or possible matches of the commands that are matched to search_string

ctrl + l -> clear -> clear the terminal 

ctrl + d -> exit from terminal

ctrl + a -> moves cursor to beginning

cttl + e -> moves cursor to end

ctrl + u -> clear the command line which we enter -> do not need to press backspace to all the way just press ctrl + u and it clears the current line of the command written
useful to password also because we cant see password and if we thought to enter wrong characters we can press ctrl + u


To check commands history -> cat .bash_history --> this file is stored in user directory
number of commands that needs to be stored is decided by environment variable -> histfilesize -> echo $HISTFILESIZE
Additionally, we can run history command to print history of bash commands
the number of commands are printed using history command is controlled by HISTSIZE environment variable --> echo $HISTSIZE

to run specific command from history --> !command_number_from_history

to run previous command withouy using up key -> !!

to check the command detail and output use -> !-number_from_the_last_command

to run last command directly with its arguments -> !command_name -> this will run command previous ran with its arguments

if you don't want to run the command and just print it then just use -> !ping:p or !rm:p -> it will display which last command was used for ping and rm

delete specific command from history --> history -d 107 --> delete command number 107 from history
delete entire history -> history -c

to not add command into history just add whitespace before running command like, --> whitespace who -a --> this will be not saved in history

if commands are still recorded in history then we can check environment variable --> HISTCONTROL
HISTCONTROL has possible three values -> ignoredups, ignorespace, ignoreboth

ignoredups -> only record history of one command if we runs the same command multiple times like, cd cd cd -> it will record only one cd in history
ignorespace -> it will not record command written using whitespace
ignoreboth -> it will not record commnd ran using whitespace and also record only one command if we run same command multiple times

by default in ubuntu this variable is set to ignoreboth and in centos it is set to ignoredups

if we change HISTCONTROL value after login it will only changed till user is logged out.
if we want to permanently store its values even after user restarts the machine we need to save it in .bashrc file
to do that run -> echo "HISTCONTROL=ignoreboth" >> .bashrc

generally history command does not show on which time command ran
to do that use -> HISTTIMEFORMAT="%d/%m/%y %T "


Gain root access -> sudo su
print your curret user access to which group -> id
it still logged in as current user but it has now admistrator rights to execute root commands

sudo su -   -> directly logged in as root --> Linux initializes all environment variable as if directly root logged in

once we run any command using sudo it will first time ask for password
but then for 5 minutes it will not ask for password and each time we run sudo command it will update time stamp and again for 5 mins not asks for password

sudo -v -> automatically updates timestamp and we don't need to run the whole command to update time stamp
sudo -k -> reset timestamp and used needs to enter password when used sudo command

by default root password is not set to set the password for root -> sudo passwd root -> prompts for password of root
once password for root is set we can just type su and it will prompt for root password and then we can logged in as root user

to change password of any user run -> sudo passwd username

home directory for root user is -> /root/
and by default root directory is -> /
so do not get confused for root user directory to root directory


File System

by default when we insert USB we need to mount it in our linux system
in gui based linux system like ubuntu it is automatically mounted
once inserted we can check USB by running -> df -h

all the hardware related files are stored in /proc folder
like, we can print cpu information using --> cat /proc/cpuinfo
there are other files are also available in this directory that we can check to analyze hardware 
/var directory used for storing system/application logs

ls displays current directory contents by default
so if we want to display current directory status and not its contet use -d option
like, ls -ld -> this command will print detail list of /etc and not its contents

file permission -> drwxrwxrwx -> indicates it is directory -> first 3 letters owner permission, group permission, other users permission

use -S option to list files as size in descending order
use -h option to see size in human readable format

by default ls command does not display original size for directory
instead we can use -> du -sh /etc/ -> to see the size of etc directory

to sort using file extension use -> ls -X
to not display specific extension file -> ls --hide=*.conf -> this will not display files that has .conf extension

to check detail or location of command use type -> type ifconfig, type ls these are some examples

file timestamp has 3 timestamps -> atime, mtime, ctime

atime -> last time file was read -> ls -lu
mtime -> last time of file content was modified -> ls -l, ls -lt
ctime -> last time when metadata of file has changed -> ls -lc

these times contains integer value which is calculated to time stamp from Jan 1 1970 UTC

to check all the time in human readable format use -> stat filename

to check full time -> ls -l --full-time filename/directory

touch usually creates the file if it does not exists in current directory and also at the same time it updates the time stamp of the file
by default if we run -> touch filename -> it updates all 3 times (atime, ctime, mtime)

to specifically modify particular time use -> touch -m filename -> it update mtime and ctime
touch -a filename -> it update atime and ctime

to modify file time stamp to previous or any specific date -> touch -at 201905200223.34 filename -> it updates only atime of the file
touch -amt 201905200223.34 filename -> it updates both atime,mtime of the file

to directly change both atime and mtime use -> touch -d "2020-04-05 14:34:23" filename

copy other file time stamp to other one use -> touch filename1.txt -r filename2.txt
it will copy time stamp of the filename2.txt to filename1.txt

to display files in sorted timestamp manner use -> ls -lt -> it displays file/directory sorting by modification time
to sort file list using access time use -> ls -ltu
to sort file using its name use -> ls -lu -> time it will shows for each file in list will be access time
to revers the order of previous command use -> ls -lu -r

to check file type use -> file filename
to rename or move file use -> mv filename1.txt filename2.txt
to move the file we need also give the file name with path -> mv filename1.txt Desktop/filename1.txt


to view content of the file use -> less filename -> use ctrl + f or space to move forward one page
to move previous one page -> ctrl + b
if we want to see live updating of file content -> less +F filename
to see line number of file -> less -N filename

using tail we cann see last 10 lines of any file by default -> tail filename
to see specific last line -> tail n -2 filename -> it will shows last 2 lines of the file
tail -n +20 filename -> it will display file content starting from line no 20 to the end
to see live updating of file -> tail -f filename

to see starting of the file -> head filename
to see specific content of file from beginning -> head -5 filename -> display first 5 lines of filename

to see live command execution use watch -> watch ls -> it periodically execute ls command and updates the output
to check updates highlighted -> watch -n 1 -d ls -l
another example -> watch -n 1 -d ifconfig
another example -> watch -n 1 -d free -m -> using this command we can see output live updates of free memory

to display message while using mkdir command -> mkdir -v directorname
to create nested directories with parent directories that are not exists -> mkdir -p first/second/third
it will create all three directories first, second and third

to copy content of files or directories use cp command
cp file1 file2 -> if file2 does not exists it will create and copy content from file1 to file2 and if exists it ovewrites the contents of file2 with file1 content
generally cp command does not prompt for overwrite and directly overwrite destination file
to prompt use -> cp -i file1 file2
to verbose information -> cp -v file1 file2
to copy files to directory -> cp file1 directorname
copy directories recursively to another directory -> cp -r /etc/ ~/Desktop
when we copy file content to other file content the owner of the file will be the one who ran the command
Like, file1 owner is A and we use -> sudo cp file1 file2 --> then root becomes owner of the file2
to preserve the ownership of the file use -> cp -p file1 file2
to recursively copy directories use -> cp -r dir1 dir2

to move files from one directory to another use -> mv source destination
to rename file -> mv file file -> this usually rename when both files remains in same directory
to prompt when file exists and you don't want to overwrite it then -> mv -i
to move latest file -> mv -u -> if source file is latest one then it will not move otherwise if destination is the latest one then it will move
same way if we want to rename the directory then use -> mv dir1 dir2
to rename file when moving even if they are not in same directory use -> mv dir1/file1 dir2/file2
it will move file1 and rename to file2 in dir2

to remove file -> rm file1
to prompt use -> rm -i file1
to remove directory -> rm -r dir
if files are write protected and you don't want prompt then use -> rm -f file1
before removing files using pattern matching like, *.txt check which are files will be deleted using rm -rf *.txt
to see which files will be deleted use -> echo *.txt

there are possibilities that files removed using rm command can be recovered
to not allow recovering of deleted files use -> shred -vu -n 100 file -> it will ovewrites 100 times file with random content and then removes it
so that recovery tools are not able to recover exact file with same content

pipe (|) allows to give 1st Command output to second command input
like, ls -lSh /etc | head -> it will display first 10 files -> head used the output of the ls command as input and displayed first 10 lines of its output
another example -> ls -lSh /etc | head -n 20 | tail -n 1 -> it will display file number 20 from ls command

in linux everything is treated as file even terminal
like, in current terminal when we write -> tty -> it will shows from which file current terminal resides
if we want to see output in the terminal then when we write something to that terminal file it will automatically update that terminal
like, tty -> /dev/pts/0 -> this is current terminal file
now open another terminal and execute -> ifconfig > /dev/pts/0
you can see that output of the 1st terminal automatically updated to ifconfig command

generally if command successfully output only then we can use redirection operator to write into the file
like, ls -l > filelist.txt or ls -l >> filelist.txt (>> will append file content and > overwrites file content)
but when the command produces error we can't simply use > and >> to write to the file
instead we can use 2> and 2>>
like, tail -n 10 /etc/passwd /etc/shadow > output.txt 2> error.txt
from the above command tail will display last 10 lines for /etc/passwd but /etc/shadow is protected so it will give error
so here /etc/passwd output will be overwritten to output.txt and error from /etc/shadow will be over to the error.txt file

to write both output and error into the same file -> tail -n 20 /etc/passwd /etc/shadow > output.txt 2>&1

if we want to see the output in addition to writing the output into the file 
use -> tee
like, ifconfig -> grep ether -> tee m.txt -> it will display mac address from ifconfig output which is found by grep command and then it also write that output into the m.txt
to append the output of file when using tee use -> tee -a file.txt

to search files use -> find and locate -> by default locate is not installed in ubuntu
to install locate in ubuntu use -> sudo apt install mlocate -> in newly version mlocate is locate
by default locate uses database stored at -> /var/lib/mlocate/mlocate.db
to check how many files, directories are indexed in database check -> locate -S

locate one -> this will search directories name as well as file names and displays with its absolute path
to only search for file name use locate -b string -> this will now not search for the string absolute path instead it will only search for file name
to search for exact file name use -> locate -b '\filename' it will search for filename as exact name to find file
everytime we use locate command there may be possibility that new files added or old files renamed
so use --> sudo updatedb

to look for the command path from where it installed use which 
like, which rm -> returns /usr/bin/rm
to list all the executables of command use -> which -a rm

find is also used for searching for the file but it has more option than locate
to find file in current directory -> find . -name filename
to search case insensitive -> find . -iname filename
find and delete at the same time -> find . -name todo.txt -delete
to also execute ls command on each file when finding use -> find . -name todo* -ls
to seach for directory -> find dirtosearch -type d
it will search recursively all the subdirectories to its total depth
to search for specific level use -> find dirtosearch -maxdepth 1 -type d -> it will display only subdirectories of dirtosearch because we specified only level 1 as maxdepth
to search files with size -> find /var -type f -size 100k -ls -> it will display files which has size around 100000 bytes
to search files greater than specific size -> find /var -type f -size +10M -ls 
to search files less than specific size -> find /var -type f -size -1k -ls
to search files in between size -> find /var -type f -size +5k -size -10k -ls
to search files as per time stamp use -> find /var -type f -atime 0 -ls -> it will display files that are accessed in 24 hours
we can use -atime, -mtime and -ctime option for respective time stamp
to search files that are accessed at least 2 days ago use -> find /var -type f -atime +1 -ls
to search files as per minutes -> find /var -type f -mmin -60 -> files that are modified in last hour
to search files per owner -> find /var -type f -user username -ls -> display files that are owned by username
to search files that are not belong to root group -> find /var -type f -not -group root -ls

to run command on each file returned by find command we can use exec option
like, find /var -type f -mtime 0 -exec cat {} \;
this will print each file content using cat command we have given in exec option
we can also use find and exec to backup the files that are modified in last 7 days
like, find /etc -type f -mtime -7 -exec cp -v {} ~/backup \;


to search for string in files use -> grep searchstring file
to search for string case insensitive -> grep -i searchstring file
to search for string with its line number in file -> grep -i -n searchstring file
to search for exact word in file use -> grep -w searchstring file -> it will display the lines of file that has exact same match as searchstring
to search for lines that don't contains the searchstring use -> grep -v searchstring file
to search for string in binary files use -> grep -a searchstring file
to search for string in files in the given directory use -> grep -R searchstring dir
to not display not existing or not readable files error while usign grep use -> grep -s searchstring /etc
to print the count of matches use -> grep -c searchstring file
to print the lines before and after the searchstring use -> grep -A 3 -B 4 searchstring file 
	-> it will display lines that are 4 lines before the matched line and 3 lines after 3 matchline
alternatively we can use -> grep -C 3 searchstring file -> that will print lines that are before and after current matched line
to exclude empty lines use -> grep -v "^$" -> ^ is the starting of the line and $ is the end of the line

to compare files use -> cmp file1 file2 -> it compare files byte and byte and displays first non compare line numbers
it also used to compare binary files
another way to compare binary files -> sha256sum file1 file2 -> it displays sha for the both files -> by checking those we can say that they are identical or not 

to display content of files that has difference use -> diff file1 file2
to ignore comparison of blank lines use -> diff -B file1 file2
to ignore comparison of white space use -> diff -w file1 file2
to ignore comparison of difference cases use -> diff -i file1 file2
to display detailed comparision use -> diff -c file1 file2
to display differences of file side by side use -> diff -y file1 file2

sudo apt install vim

to edit multiple files at the same time use -> vim a b -> and press ctrl + w to switch between
we can also compare files using vim -> vim -d file1 file2

to compress the directory -> sudo tar -czvf etc.tar.gz /etc/


Each file has data structure associated with it called inode structure -> that contains file meta data, type, size, permission, timestamp all stored in inode structure except name and content
when we create a new file it will store the name and its inode number in directory
then when we try to search or display file content using cat file it will get its information from inode number from directory
the directory stores file name with its absolute path 
association between file structure and file name called hard link
as file name is associated to inode number
to point to same inode structure or to use same hard link for other file use -> ln file1 file2
file2 has now same inode number as file1 has
and changing file1 or file2 will effect other one
but when we remove other file it will not remove files which has same inode number
it will only remove entry from directory and decrement of the count of hard link
to find the files associated with the same inode number use -> find . -inum inodenumber

to find the number of hard links of files in the directory use -> find /usr -type f -links +1 -ls

to create symlink use -> ln -s file1 file2
when we delete a file hard link will be remain for other files but symlink will be destroyed

User Accoung Management

there are 2 main files for users in Linux
1 -> /etc/passwd -> contains basic informations of the user accounts of the system
2 -> /etc/shadow -> contains password for each user in hash/encrypted password

user generally has one primary group and can be in multiple secondary groups
to check that we can see /etc/passwd
also, /etc/group and search for user to which secondary group user is belong to
to print all the detail of user like userid, groupid and secondary group details use -> id
to print groups of user use -> groups username
groups -> this will display current user groups

to create new user -> sudo useradd u1
to check newly created user list use -> tail -n 5 /etc/passwd
by default when user is created linux system automatically create and assign group to user which has same name as user
useradd command generally differs in linux distributions
by default -> sudo useradd u1 -> will not create user home directory for u1
there are so many manual options for useradd command
to create user home directory when executing useradd command use -m option
to create custom user home directory when executing useradd command use -d option like, -> useradd -d /home/james username
to add comment for user when executing useradd command use -c option like, -> useradd -c "Test User" u1
to add specific shell to user when it opens terminal or login use -s option like, -> useradd -s /bin/bash u1
to assign different primary group to user when creating use -> useradd -g groupname username
for secondary groups use -> useradd -G g1,g2,g3 username
to add expiration date for user use -> useradd -e 2020-12-12 username
to check password expiration policy and other details for expiration use -> sudo chage -l username

once user is created and then if we want to change user properties use -> usermod
usermod -g G1 username -> change primary group of username to G1
usermod -G G1,G2 username -> chang secondary groups of username to G1, G2
usermod -c "Developer" username -> to add comment for the username
to delete user use -> userdel username
by default userdel also deletes the group which has the same name as username along with user
if this group is associated to some other user then group will not be deleted
by default userdel command does not delete users home directory
to delete user home directory when executing userdel use -> userdel -r username
to allow user to run administrative commands we need to assign the user to sudo group
usermod -g sudo username -> assign username to sudo group

to create group -> groupadd groupname 
to rename the group -> sudo groupmod -n g1 g2

w -> displays logged in users in the current system and the process they are running
last -> displays list of last logged in users
uptime -> each time users logged in users it will display total number of logged in users
to find activity of particular user -> last username

File Permissions

each file or directory has owner and group
by default user who creates the file or directory will become the owner of the file and group assigned to the file is the one user has as primary group
ownership of the file or directory can be changed by root using chown and chgrp

there are 3 permissions -> r(read), w(write), x(execute)
to view file the permission -> ls -l or stat
permissions is divided in 3 parts -> owner(rwx), group(rwx), everybody else(rwx) like, -rw-r--r--
first one indicates the type of file or directory and other 9 are divided in each 3 permission as mentioned above

file permission concept does not applicable for root even though there are no permissions given to file root can still read,write and execute the file
like, file1 has ---------- permissions that means no users can read,write and execute except root

linux file permissions can be also applied or viewed as octal notations
to view the file permissions in symbolic and octal format use -> stat /etc/shadow
each permission has octal notation like, r-4, w-2, x-1, -(no permission)-0

chmod u-w file -> removes write permissions for user from file
chmod u+rwx file -> add read,write and execute permission for user for file
chmod u-x,g+w,o-rwx -> remove execute permission for user, add write permission for group and removes all permission for other users for specified file
to display detail when chmod execute use -v option
chmod ug-r,u+w,g+x,o-rwx -> removes read permission for user and group, add write permission for user and execute permission for group 
							and removes read,write and execute permissions for other users

chmod a+r,a-wx file -> add read permission and removes write and execute permission for user,group,others from file
chmod ug=rw,o= file-> set read,write permission for owner and group and no permission for others -> note that there white space after o=
chmod 644 file -> read,write for owner, read for group and others
to view list of files recursively from directory use -> ls -lR dir
to give permission recursively to directory and files within subdirectories as well use -> chmod -R 744 dir
to give permission to file from another file use -> chmod --reference=file1 file2

to change only files permissions from within directory use -> find dir -type f -exec chmod 644 {} \;
for directory just use -> find dir type -d -exec chmod 644 {} \;

change file owner
chown username filename -> need to run using root
we can specifiy multiple files or directories in chown







